# Видача решти: жадібний алгоритм vs динамічне програмування

## Огляд

У цьому проєкті порівняно два підходи до задачі видачі решти
для касового апарату з фіксованим набором монет:

`[50, 25, 10, 5, 2, 1]`

Використані алгоритми:
- **Жадібний алгоритм** — завжди вибирає найбільший доступний номінал
- **Динамічне програмування** — знаходить мінімальну кількість монет для будь-якої суми

---

## Мета роботи

1. Реалізувати **жадібний алгоритм** та **алгоритм динамічного програмування**
2. **Порівняти** їхню продуктивність
3. Пояснити, чому один алгоритм працює швидше за інший для великих сум
4. Зробити висновки щодо практичного використання алгоритмів

---

## Налаштування експерименту

- Мова програмування: **Python**
- Вимірювання часу: модуль **`timeit`**
- Кількість запусків для усереднення: **2000**
- Тестовані суми: [10, 234, 1567, 5987, 12345, 20000]

---

## Результати вимірювань

### Середній час виконання одного виклику (секунди)

| Сума | Жадібний алгоритм | Динамічне программування |
|-----:|------------------:|-------------------------:|
| 10 |      0.00000026 s |             0.00000309 s |
| 234 |      0.00000041 s |             0.00008454 s |
| 1567 |      0.00000040 s |             0.00064194 s |
| 5987 |      0.00000039 s |             0.00252180 s |
| 12345 |      0.00000035 s |             0.00516694 s |
| 20000 |      0.00000027 s |             0.00849704 s |

---

## Аналіз результатів

### 1. Жадібний алгоритм

- Час виконання **практично не змінюється** при зростанні суми
- Причина:
  - Алгоритм проходить лише по списку номіналів монет
  - Кількість монет фіксована → **O(k)**, де `k = 6`
- Дуже швидкий навіть для великих сум (20 000 і більше)

### 2. Динамічне програмування

- Час виконання **зростає лінійно** зі збільшенням суми
- Причина:
  - Алгоритм обчислює оптимальне рішення для **кожного значення від 1 до суми**
  - Часова складність: **O(amount × k)**
- Гарантує мінімальну кількість монет для будь-якої системи номіналів

---


## Висновки

1. **Жадібний алгоритм є значно швидшим** і краще масштабується для великих сум.
2. Для системи монет `[50, 25, 10, 5, 2, 1]` жадібний алгоритм **завжди дає оптимальний результат**.
3. **Динамічне програмування є універсальним**, але його використання для великих сум є менш ефективним з точки зору часу.
4. У реальних касових системах зазвичай використовують **жадібний алгоритм**, оскільки він:
   - простий
   - дуже швидкий
   - достатньо точний для стандартних наборів монет

> **Динамічне програмування доцільне тоді, коли набір монет нетиповий
> або жадібний алгоритм не гарантує оптимального рішення.**